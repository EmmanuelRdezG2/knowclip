// @flow
import * as r from '../redux'
import { toTimestamp } from '../utils/ffmpeg'
import { extname, basename } from 'path'
import { unparse } from 'papaparse'
import { getNoteTypeFields } from '../utils/noteType'
const SAFE_SEPARATOR = '-'
const SAFE_MILLISECONDS_SEPARATOR = '_'

export const getApkgExportData = (
  state: AppState,
  projectMetadata: ProjectMetadata,
  clipIds: Array<ClipId>
): ApkgExportData => {
  const fieldNames = getNoteTypeFields(projectMetadata.noteType)
  const [firstFieldName, ...restFieldNames] = fieldNames
  const mediaFilePaths = r.getMediaFilePaths(state, projectMetadata.id)
  // const mediaMetadata = r.getProjectMediaMetadata(state, projectMetadata.id)

  // sort and validate
  clipIds.sort((id, id2) => {
    const clip = r.getClip(state, id)
    if (!clip) throw new Error('Could not find clip ' + id)

    const clip2 = r.getClip(state, id2)
    if (!clip2) throw new Error('Could not find clip ' + id2)

    const metadataAndPath = mediaFilePaths.find(
      mAndP => mAndP.metadata.id === clip.fileId
    )
    if (!metadataAndPath)
      throw new Error(`Couldn't find media metadata for clip ${id}`)
    const { metadata, filePath } = metadataAndPath
    if (!filePath)
      throw new Error(`Please open ${metadata.name} and try again.`)

    const metadataAndPath2 = mediaFilePaths.find(
      mAndP => mAndP.metadata.id === clip.fileId
    )
    if (!metadataAndPath2)
      throw new Error(`Couldn't find media metadata for clip ${id}`)

    const fileIndex1 = mediaFilePaths.indexOf(metadataAndPath)
    const fileIndex2 = mediaFilePaths.indexOf(
      mediaFilePaths.find(mAndP => mAndP.metadata.id === clip2.fileId)
    )
    if (fileIndex1 < fileIndex2) return -1
    if (fileIndex1 > fileIndex2) return 1

    if (clip.start < clip2.start) return -1
    if (clip.start > clip2.start) return 1
    return 0
  })

  const clips = clipIds.map(id => {
    const clip = r.getClip(state, id)
    if (!clip) throw new Error('Could not find clip ' + id)

    const metadataAndPath = mediaFilePaths.find(
      mAndP => mAndP.metadata.id === clip.fileId
    )
    if (!metadataAndPath)
      throw new Error(`Couldn't find media metadata for clip ${id}`)
    const { metadata, filePath } = metadataAndPath
    if (!filePath)
      throw new Error(`Please open ${metadata.name} and try again.`)

    const extension = extname(filePath)
    const filenameWithoutExtension = basename(filePath, extension)

    const startTime = r.getMillisecondsAtX(state, clip.start)
    const endTime = r.getMillisecondsAtX(state, clip.end)
    const outputFilename = `${filenameWithoutExtension}___${toTimestamp(
      startTime,
      SAFE_SEPARATOR
    )}-${toTimestamp(
      endTime,
      SAFE_SEPARATOR,
      SAFE_MILLISECONDS_SEPARATOR
    )}___afcaId${id}${'.mp3'}`
    return {
      sourceFilePath: filePath,
      startTime,
      endTime,
      outputFilename,
      flashcardSpecs: {
        fields: [
          clip.id,
          ...fieldNames.map(f => clip.flashcard.fields[f] || ''),
          `[sound:${outputFilename}]`,
        ],
        tags: clip.flashcard.tags || [],
      },
    }
  })
  // })
  // .reduce((a, b) => a.concat(b))

  return {
    deckName: `${projectMetadata.name} (Generated by AFCA)`,
    template: {
      fields: ['id', ...fieldNames, 'sound'],
      questionFormat: `{{${firstFieldName}}} {{sound}}`,
      answerFormat: `{{FrontSide}}\n\n<hr id="answer">\n\n${restFieldNames
        .map(fieldName => `{{${fieldName}}}`)
        .join('<br />')}`,
    },
    clips,
  }
}

export const getCsvText = (exportData: ApkgExportData): string => {
  const csvData: Array<Array<string>> = exportData.clips.map(
    ({ flashcardSpecs }) =>
      [...flashcardSpecs.fields].concat(flashcardSpecs.tags.join(' '))
  )

  return unparse(csvData)
}

// web
// const exportCsv = (files, flashcards) => {
//   const usableFlashcards = files
//     .map(file => flashcards[file.name])
//     .filter(({ de, en }) => de.trim() || en.trim())
//     .map(({ en, de }, i) => [de, en, `[sound:${files[i].name}]`])
//   // TODO: alert if no usable
//   let csv = unparse(usableFlashcards)
//   const filename = 'export.csv'
//
//   if (!csv.match(/^data:text\/csv/i)) {
//     csv = 'data:text/csv;charset=utf-8,' + csv
//   }
//   const data = encodeURI(csv)
//
//   const link = document.createElement('a')
//   link.setAttribute('href', data)
//   link.setAttribute('download', filename)
//   link.click()
// }
